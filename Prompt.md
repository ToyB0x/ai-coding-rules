# Prompt

## 目次
- [概要と利用方法](#概要と利用方法)
- [ドキュメント作成・更新のルール](#ドキュメント作成更新のルール)
- [作成・更新すべき資料](#作成更新すべき資料)
  - [プロジェクト/リポジトリのドキュメンテーションガイド](#プロジェクトリポジトリのドキュメンテーションガイド)
  - [プロジェクト理解のための資料](#プロジェクト理解のための資料)
  - [Clineのためのルールとガイドライン](#clineのためのルールとガイドライン)
    - [コミットの提案とメッセージ記録](#コミットの提案とメッセージ記録)
  - [コード理解のための手順とコツ](#コード理解のための手順とコツ)
  - [モノレポ構造のドキュメント](#モノレポ構造のドキュメント)
- [Changelog](#changelog)

## 概要と利用方法

このドキュメントは、ClineなどのLLMを活用したGitリポジトリでの開発のベストプラクティスをまとめたものです。ここには、AI支援開発における推奨されるルールやガイドラインが集約されています。

### 目的

- GitリポジトリにおけるClineなどのLLMの効果的な活用方法をまとめる
- プロジェクトにおけるドキュメント管理や更新のベストプラクティスを定義する
- コミット提案やコード理解など、AI支援開発における様々な側面のガイドラインを提供する

### 利用タイミング

ClineなどのLLMは、**リポジトリ作成初期だけでなく、任意のタイミング**でこの資料を参照し、ベストプラクティスの追加導入や適用を検討すべきです。特に以下のようなタイミングでの参照が推奨されます：

- 新規プロジェクト開始時
- 新機能開発の計画段階
- コードベースのリファクタリング前
- チーム開発プロセスの見直し時
- 既存プロジェクトへのAI支援開発の導入時

### 参照方法

このドキュメントは以下のURLから直接参照することを想定しています：
```
https://raw.githubusercontent.com/ToyB0x/ai-coding-rules/refs/heads/main/Prompt.md
```

LLMは上記URLを参照してベストプラクティスを取得し、プロジェクトの状況に合わせて適切に適用することが期待されています。

## ドキュメント作成・更新のルール

- Clineによる作業の前に作成・更新対象のドキュメント一覧を人間に確認し、その時々に応じて対象を取捨選択できるようにすること
- 資料冒頭に更新日と確認日のセクションを配置し、更新日時を記載すること
- 資料後半にChangelogのセクションを配置し、変更内容と変更日時を記載すること(古い変更内容は適宜整理すること)
- 似た目的の既存の資料がある場合は既存の資料を参考にした上で、内容に意味的な大きな変化がない場合には人間が確認する負担を減らすため確認日のみ更新し、その他の内容は変更しないこと
- 資料作成・更新にあたって不明な点があればClineなどのLLMは遠慮せずに質問すること
- .gitignore 等で ignore されているファイルは、Clineが作成・更新する資料の対象外とすること

## 作成・更新すべき資料

### プロジェクト/リポジトリのドキュメンテーションガイド

- 本資料・プロンプトの指針や参考例だけでなく、既存のプロジェクトの状況とのバランスを考慮し、プロジェクトごとにカスタマイズした内容を記載
- 人もLLMも常にこのガイドを参照し、プロジェクトのドキュメンテーションを行うことを前提とする
- このガイドと現状のズレを検知した場合、Cline等のLLMは人間に確認し、ガイド・現状資料のどちらかまたは両方の更新を提案すること

### プロジェクト理解のための資料

#### プロジェクトの目的と概要資料

プロジェクトの目的や、各種オンボーディング資料を/docs/guide/ 配下等に作成・更新（プロジェクトの目的等が見つからない場合はClineは人間に必ず確認しなければならない）

#### 現行プロダクトのドキュメント

既に開発済みの現時点のプロダクトが提供する機能、価値等をまとめた各種ドキュメント：

- ユーザーマニュアル/ユーザーガイド（一般ユーザー向けの操作方法や機能説明）
- 機能一覧/仕様書（開発者やステークホルダー向けの詳細な機能説明と仕様）
- API仕様書/インターフェース定義（他システムとの連携方法やAPIエンドポイントの説明）
- アーキテクチャ概要図（技術スタック、システム構成、コンポーネント間の関係性）
- データモデル図/ER図（データ構造や関連性の説明）
- トラブルシューティングガイド（一般的な問題とその解決方法）
- リリースノート/変更履歴（各バージョンでの変更点や新機能の説明）

#### 機能開発ロードマップ

今後の機能開発のロードマップ（/docs/guide/roadmap.md 等に作成・更新。存在しない場合や不明な場合、数週間以上更新されていない場合はClineは人間に必ず確認しなければならない）

#### 機能開発のドキュメント設計

上記の各ロードマップを実現するための各機能開発で準備すべきドキュメントの種類、場所、作成・更新のタイミングと方法。さらにそれぞれの前提となる各開発ステップの全体像について記載。

##### ドキュメントの種類の例

**Product Requirement Document**
機能の「なぜ」と「何を」を理解するためのドキュメント（機能開発の目的、概要、要件、ユーザーストーリー、先行事例や参考事例、リリースノート等の記載）

**Technical Design Document**
機能の「どのように」を理解するためのドキュメント（機能開発の設計、アーキテクチャ、データフロー、API設計等の記載。ドキュメントサイズは人間のキャパシティを考慮して以下の複数ファイルに分割することを推奨）

- */Technical-Design/README.md (全体を俯瞰できるIndexや、全体の技術的な概要、設計の参考となる文献や資料のURLなど)
- */Technical-Design/packages/[変更・追加多少のパッケージ名]/README.md (機能追加のための既存パッケージの改修ポイントについて、パッケージのREADMEレベルや、基本設計レベルでまとめたもの)
- */Technical-Design/packages/[変更・追加多少のパッケージ名]/implements.md (上記の変更を実装するための詳細な設計書。文量が多い場合はさらにサブディレクトに細分化して分割)
- */Technical-Design/packages/[変更・追加多少のパッケージ名]/tests.md (上記の変更をテストするための詳細な設計書。文量が多い場合はさらにサブディレクトに細分化して分割)
- */Technical-Design/architecture.md (アーキテクチャ) (上記のパッケージ間の関係性をまとめたアーキテクチャの全体像)
- */Technical-Design/E2E.md (E2Eテスト) (上記の機能追加に対するE2Eテストについて記載)
- 上記例以外にも、目的や必要な開発ステップに応じて柔軟にドキュメントを追加すること

##### 開発ステップの例

1. 要件定義ステップ: Product Requirement Documentを作成しレビューする
2. 技術検討ステップ: Technical Design Documentを作成しレビューする
3. 実装ステップ: 上記のTechnical Design Documentをもとに、実装、コードレビューを行う
4. テストステップ: 上記のTechnical Design Documentをもとに、テストを実施する
5. リリースステップ: 上記のTechnical Design Documentをもとに、リリースを実施する
6. リリース後の振り返りステップ: 上記のTechnical Design Documentをもとに、振り返りを実施し、開発フローの改善等を行う
7. リリースした新機能の評価ステップ: 顧客の反応などをもとに将来の機能開発の参考にする

### Clineのためのルールとガイドライン

#### Clineのための参考資料

- .clinerules/README.md (.clinerules配下の全体を俯瞰できるIndex)
- .clinerules/important-docs.md (前述のプロジェクトの重要な資料の場所を cline が参照しやすいようにまとめたもの)

#### コミットの提案とメッセージ記録

##### コミットメッセージの基本記録ルール

.clinerules/commit-rules.md には以下のような内容をClineが記録すべきであることが記載されています：

```
Prompt History:
Q: ユーザーからの質問や指示1
A: AIからの回答や実行内容の要約1

Q: ユーザーからの質問や指示2
A: AIからの回答や実行内容の要約2
```

##### コミットの提案に関するガイドライン

.clinerules/commit-proposal.md には、LLMが作業完了時に積極的にコミットを提案すべき内容をまとめています。具体的には以下のような内容が記載されています：

###### コミット提案のタイミング
- タスクや作業の完了時に毎回積極的にコミットを提案すること
- 複数のファイルの変更を伴う場合は特に重要
- 論理的なまとまりのある変更ごとに提案すること（複数の無関係な変更を一つのコミットにまとめないこと）
- ユーザーが明示的にコミットを求めなくても、作業完了時には自発的に提案すること

###### コミットメッセージの構造
コミットメッセージは以下の構造に従うこと：

```
<種類>: <簡潔な要約>

<詳細な説明>

<変更されたファイル一覧>

<プロンプト履歴>
```

###### 種類（Type）の例：
- feat: 新機能
- fix: バグ修正
- docs: ドキュメントのみの変更
- style: コードの意味に影響を与えない変更（空白、フォーマット、セミコロンの欠落など）
- refactor: バグ修正でも機能追加でもないコード変更
- test: テストの追加・修正
- chore: ビルドプロセスやドキュメント生成などの変更

###### コミットメッセージに含めるべき情報
- 変更内容の簡潔かつ明確な要約
- 変更の理由や背景（必要に応じて）
- 変更されたファイルの一覧
- 関連するIssue番号やチケット番号（該当する場合）
- **プロンプト履歴**（重要：作業内容の追跡と判断根拠の記録として必須）

###### プロンプト履歴の記録ルール
プロンプト履歴は以下の形式で記録し、必ずコミットメッセージに含めること：

```
Prompt History:
Q: ユーザーからの質問や指示1
A: AIからの回答や実行内容の要約1

Q: ユーザーからの質問や指示2
A: AIからの回答や実行内容の要約2
```

**プロンプト履歴に記録する情報**:
1. **ユーザーの質問・指示**
   - 元の質問や指示をそのまま記録
   - 長文の場合は核となる部分を抽出して記録

2. **AIの回答・実行内容**
   - 実行したアクションの要約
   - 重要な決定事項
   - 生成したコードやファイルの概要

**記録時の注意点**:
- 簡潔さと具体性のバランスを保つ
- 重要な意思決定の理由を含める
- 変更したファイルのパスを明記する
- 関連する一連の対話はまとめて記録する

###### ユーザーとのインタラクション
- コミット提案時には、メッセージ案を提示してユーザーの承認を得ること
- 提案を修正できるよう、コミットメッセージを編集可能な形で提示すること
- コミットコマンド（git commit -m "..."）を実行する準備ができていることを伝えること

###### コミットメッセージの完全な例

**例1：新機能追加の場合**
```
feat: ユーザー認証機能の実装

- JWTを使用したユーザー認証システムを実装
- ログイン、ログアウト、トークン更新のエンドポイントを追加
- 認証ミドルウェアを実装して保護されたルートを作成

変更ファイル：
- src/auth/authController.js
- src/auth/authMiddleware.js
- src/routes/authRoutes.js
- src/models/User.js

Prompt History:
Q: ユーザー認証システムを実装してください。JWTを使用してください。
A: JWTベースの認証システムを実装。authController.jsでトークン生成・検証、authMiddleware.jsで認証ミドルウェア、authRoutes.jsでルート定義、User.jsでモデル実装。

Q: 認証トークンの有効期限設定はどうすればいいですか？
A: authController.jsにて、アクセストークンに1時間、リフレッシュトークンに7日間の有効期限を設定。リフレッシュトークンエンドポイントも実装。
```

**例2：バグ修正の場合**
```
fix: ユーザープロファイル更新時のバリデーションエラーを修正

- 空の入力フィールドを適切に処理するようにバリデーションロジックを修正
- エラーメッセージをより具体的にして、ユーザーが問題を特定しやすくした

変更ファイル：
- src/validators/userValidator.js
- src/controllers/userController.js

Prompt History:
Q: プロファイル更新時に空の入力があるとエラーになる問題を修正してください
A: userValidator.jsでバリデーションロジックを修正し、空入力を許容するように変更。また、エラーメッセージをより具体的に改善。

Q: テストケースも更新してください
A: 空入力を許容するケースのテストを追加。境界値テストも実装。
```

**例3：ドキュメント更新の場合**
```
docs: READMEとAPIドキュメントの更新

- インストール手順を明確化
- 新しいエンドポイントのドキュメントを追加
- 設定オプションの説明を更新

変更ファイル：
- README.md
- docs/api.md

Prompt History:
Q: APIドキュメントを更新して、新しいエンドポイントの情報を追加してください
A: docs/api.mdを更新し、新しいエンドポイントの詳細（パラメータ、レスポンス形式、エラーコード）を追加。

Q: READMEも更新してインストール手順を明確にしてください
A: README.mdのインストールセクションを更新。依存関係、環境変数設定、オプション設定についての説明を追加。
```

#### Clineへの指示資料

- .clinerules/prompts/update-docs.md (clineが資料を更新する際の内容やルールを人間にもAIにもわかるようにまとめたもの)
- README.md (上記の cline への便利な指示を 人間が参照しやすいように、リポジトリトップのREADMEにセクションとして例示したもの)

### コード理解のための手順とコツ

Clineがリポジトリのコードを適切に、効率の良いコストで理解するための手順やコツをまとめた資料：

#### Repomixの活用

.clinerules/repomix.md には以下のような内容をClineが理解した上で、優先してRepomixを活用すべきであることが記載されています：

- repomixのMCPを利用してコードを効率的に理解する重要性
- リポジトリ内の特定パッケージを調べる場合にrepomixを利用してパッケージ分析を行うことがかなり強く推奨されることやその理由
- リポジトリ内の特定パッケージが数十ファイル以上を含む場合、repomixを使わないケースではAIのAPIサーバと数十回以上の通信の往復が発生して人間にストレスを与えたり開発速度へ悪影響がでるが、Repomixを活用すれば関数のシグネチャだけ効果的に分析できるので分析時間を短縮できること
- Repomixはリポジトリ全体、特定パッケージ配下のみ、特定ディレクトリ配下のみとさまざまな階層で利用でき、目的に合わせてどう使い分けるべきかの説明
- repomixのMCPが設定されていない場合はClineがユーザにセットアップを促さなければならない旨

### モノレポ構造のドキュメント

リポジトリがモノレポである場合に、モノレポ内の各パッケージのREADMEの作成・更新：

- /apps/web/README.md
- /packages/database/README.md

## Changelog

### 2025/03/22

- [削除] 「参考資料: Cline Prompting Guide」セクションを削除
- [追加] 目的や利用方法のセクションを資料前半に追加
- [追加] ドキュメントの目次（TOC）をドキュメント最上段に追加
- [改善] 折りたたみマークダウン記法を廃止し、適切なセクション構造に変更
- [追加] cline が遵守または参考にすべき情報として、LLMが作業完了時に積極的にコミットを提案すべき内容（.clinerules/commit-proposal.md）を追加
- [追加] コミット提案のタイミング、メッセージの構造、含めるべき情報、ユーザーとのインタラクション方法、具体的な例を追加
- [強調] プロンプト履歴をコミットメッセージに含めることの重要性と具体的な記録方法を詳細に説明

### 2025/03/21

- [追加] 作成・更新すべき資料一覧の参考例を追加
- [追加] 「参考資料: Cline Prompting Guide」セクションを追加
- [変更] 作成・更新のルールを明確化
